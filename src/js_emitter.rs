// JS Emitter - Generates complete JavaScript files for server and client
//
// This module combines:
// 1. RPC stubs/handlers from RPCGenerator
// 2. Actual function implementations (converted from WASM or AST)
// 3. Runtime imports and setup code
// 4. Main entry point code
//
// Output:
// - server.js: Server-side code with HTTP server and RPC handlers
// - client.js: Client-side code with RPC stubs and UI components

use crate::ast::{Program, Statement, FunctionDefinition, ComponentDefinition, Expression, BlockStatement};
use crate::code_splitter::CodeSplitter;
use crate::rpc_generator::RPCGenerator;

#[derive(Debug, Clone)]
pub struct JSEmitter {
    pub splitter: CodeSplitter,
}

impl JSEmitter {
    pub fn new(program: &Program) -> Self {
        let mut splitter = CodeSplitter::new();
        splitter.split(program);
        JSEmitter { splitter }
    }

    /// Generates the complete server.js file
    pub fn generate_server_js(&self) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("// Auto-generated RavensOne Server Bundle\n");
        output.push_str("// DO NOT EDIT - Generated by RavensOne compiler\n\n");

        // Import runtime
        output.push_str("const { HttpServer, loadWasm } = require('../dist/server-runtime.js');\n");
        output.push_str("const fs = require('fs');\n");
        output.push_str("const path = require('path');\n\n");

        // Load WASM module
        output.push_str("// Load WebAssembly module\n");
        output.push_str("const wasmPath = path.join(__dirname, 'app.wasm');\n");
        output.push_str("const wasmBytes = fs.readFileSync(wasmPath);\n");
        output.push_str("const wasmModule = new WebAssembly.Module(wasmBytes);\n");
        output.push_str("const wasmInstance = new WebAssembly.Instance(wasmModule, {\n");
        output.push_str("  env: {\n");
        output.push_str("    memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }),\n");
        output.push_str("  }\n");
        output.push_str("});\n\n");

        // Generate server function implementations
        output.push_str("// Server function implementations\n");
        for func in &self.splitter.server_functions {
            output.push_str(&self.generate_function_impl(func, true));
            output.push_str("\n\n");
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        for func in &self.splitter.shared_functions {
            output.push_str(&self.generate_function_impl(func, true));
            output.push_str("\n\n");
        }

        // Generate RPC handlers
        output.push_str("// RPC Server Setup\n");
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        output.push_str(&rpc_gen.generate_server_handlers());

        output
    }

    /// Generates the complete client.js file
    pub fn generate_client_js(&self) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("// Auto-generated RavensOne Client Bundle\n");
        output.push_str("// DO NOT EDIT - Generated by RavensOne compiler\n\n");

        // Import runtime
        output.push_str("import { RPCClient, mountComponent } from '../dist/client-runtime.js';\n\n");

        // Generate RPC client stubs
        output.push_str("// RPC Client Setup\n");
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        output.push_str(&rpc_gen.generate_client_stubs());
        output.push_str("\n");

        // Generate client function implementations
        output.push_str("// Client function implementations\n");
        for func in &self.splitter.client_functions {
            output.push_str(&self.generate_function_impl(func, false));
            output.push_str("\n\n");
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        for func in &self.splitter.shared_functions {
            output.push_str(&self.generate_function_impl(func, false));
            output.push_str("\n\n");
        }

        // Generate component implementations
        output.push_str("// UI Components\n");
        for comp in &self.splitter.client_components {
            output.push_str(&self.generate_component_impl(comp));
            output.push_str("\n\n");
        }

        // Generate main entry point
        output.push_str("// Initialize application\n");
        output.push_str("window.addEventListener('DOMContentLoaded', () => {\n");
        output.push_str("  console.log('RavensOne client initialized');\n");

        // Auto-mount first component if exists
        if let Some(comp) = self.splitter.client_components.first() {
            output.push_str(&format!("  mountComponent({}, document.getElementById('app'));\n", comp.name.value));
        }

        output.push_str("});\n");

        output
    }

    /// Generates a JavaScript function implementation from AST
    fn generate_function_impl(&self, func: &FunctionDefinition, is_server: bool) -> String {
        let name = &func.name.value;
        let params = func.parameters
            .iter()
            .map(|p| p.name.value.clone())
            .collect::<Vec<_>>()
            .join(", ");

        let async_keyword = if func.is_async { "async " } else { "" };
        let export_keyword = if is_server { "module.exports." } else { "export " };

        let body = self.generate_block_js(&func.body);

        format!(
            "{}{}function {}({}) {{\n{}\n}}",
            export_keyword, async_keyword, name, params, body
        )
    }

    /// Generates a JavaScript component implementation from AST
    fn generate_component_impl(&self, comp: &ComponentDefinition) -> String {
        let name = &comp.name.value;
        let params = comp.parameters
            .iter()
            .map(|p| p.name.value.clone())
            .collect::<Vec<_>>()
            .join(", ");

        let body = self.generate_expression_js(&comp.body);

        format!(
            "export function {}({}) {{\n  return {};\n}}",
            name, params, body
        )
    }

    /// Generates JavaScript code for a block statement
    fn generate_block_js(&self, block: &BlockStatement) -> String {
        let mut output = String::new();

        for stmt in &block.statements {
            output.push_str("  ");
            output.push_str(&self.generate_statement_js(stmt));
            output.push_str("\n");
        }

        output
    }

    /// Generates JavaScript code for a statement
    fn generate_statement_js(&self, stmt: &Statement) -> String {
        match stmt {
            Statement::Let(let_stmt) => {
                // All let statements become 'let' in JS (RavensOne tracks mutability)
                let value = self.generate_expression_js(&let_stmt.value);
                format!("let {} = {};", let_stmt.name.value, value)
            }
            Statement::Return(ret_stmt) => {
                let value = self.generate_expression_js(&ret_stmt.value);
                format!("return {};", value)
            }
            Statement::Expression(expr) => {
                format!("{};", self.generate_expression_js(expr))
            }
            Statement::If(if_stmt) => {
                let condition = self.generate_expression_js(&if_stmt.condition);
                let then_body = self.generate_block_js(&if_stmt.then_branch);

                if let Some(else_branch) = &if_stmt.else_branch {
                    let else_body = match &**else_branch {
                        Statement::If(_) => self.generate_statement_js(else_branch),
                        _ => format!("{{\n{}\n  }}", self.generate_statement_js(else_branch)),
                    };
                    format!("if ({}) {{\n{}\n  }} else {}", condition, then_body, else_body)
                } else {
                    format!("if ({}) {{\n{}\n  }}", condition, then_body)
                }
            }
            Statement::While(while_stmt) => {
                let condition = self.generate_expression_js(&while_stmt.condition);
                let body = self.generate_block_js(&while_stmt.body);
                format!("while ({}) {{\n{}\n  }}", condition, body)
            }
            _ => "// Unsupported statement".to_string(),
        }
    }

    /// Generates JavaScript code for an expression
    fn generate_expression_js(&self, expr: &Expression) -> String {
        match expr {
            Expression::Identifier(ident) => ident.value.clone(),
            Expression::IntegerLiteral(value) => value.to_string(),
            Expression::FloatLiteral(value) => value.clone(),
            Expression::StringLiteral(value) => format!("\"{}\"", value),
            Expression::BoolLiteral(value) => value.to_string(),
            Expression::Infix(infix) => {
                let left = self.generate_expression_js(&infix.left);
                let right = self.generate_expression_js(&infix.right);
                let op = &infix.operator.lexeme;
                format!("({} {} {})", left, op, right)
            }
            Expression::Prefix(prefix) => {
                let operand = self.generate_expression_js(&prefix.right);
                format!("({}{})", prefix.operator.lexeme, operand)
            }
            Expression::FunctionCall(call) => {
                let func = self.generate_expression_js(&call.function);
                let args = call.arguments
                    .iter()
                    .map(|arg| self.generate_expression_js(arg))
                    .collect::<Vec<_>>()
                    .join(", ");

                // Check if this is a server function call from client-side
                if let Expression::Identifier(ident) = &*call.function {
                    if self.is_server_function(&ident.value) {
                        return format!("await {}({})", func, args);
                    }
                }

                format!("{}({})", func, args)
            }
            Expression::IndexAccess(index) => {
                let array = self.generate_expression_js(&index.array);
                let idx = self.generate_expression_js(&index.index);
                format!("{}[{}]", array, idx)
            }
            Expression::ArrayLiteral(array) => {
                let elements = array.elements
                    .iter()
                    .map(|elem| self.generate_expression_js(elem))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("[{}]", elements)
            }
            Expression::StructLiteral(struct_lit) => {
                let fields = struct_lit.fields
                    .iter()
                    .map(|(name, value)| {
                        format!("{}: {}", name.value, self.generate_expression_js(value))
                    })
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{{ {} }}", fields)
            }
            Expression::FieldAccess(field) => {
                let object = self.generate_expression_js(&field.object);
                format!("{}.{}", object, field.field.value)
            }
            Expression::JsxElement(jsx) => {
                self.generate_jsx_js(jsx)
            }
            _ => "/* Unsupported expression */".to_string(),
        }
    }

    /// Generates JavaScript code for JSX
    fn generate_jsx_js(&self, jsx: &crate::ast::JsxElement) -> String {
        let tag = &jsx.opening_tag.name.value;

        // Generate attributes
        let attrs = if jsx.opening_tag.attributes.is_empty() {
            String::new()
        } else {
            let attrs_str = jsx.opening_tag.attributes
                .iter()
                .map(|(attr)| {
                    let val = self.generate_expression_js(&attr.value);
                    format!("{}: {}", attr.name.value, val)
                })
                .collect::<Vec<_>>()
                .join(", ");
            format!(", {{ {} }}", attrs_str)
        };

        // Generate children
        let children = jsx.children
            .iter()
            .map(|child| match child {
                crate::ast::JsxChild::Element(elem) => self.generate_jsx_js(elem),
                crate::ast::JsxChild::Text(text) => format!("\"{}\"", text),
                crate::ast::JsxChild::Expression(expr) => self.generate_expression_js(expr),
            })
            .collect::<Vec<_>>()
            .join(", ");

        if children.is_empty() {
            format!("h('{}'{}, null)", tag, attrs)
        } else {
            format!("h('{}'{}, {})", tag, attrs, children)
        }
    }

    /// Checks if a function name is a server function
    fn is_server_function(&self, name: &str) -> bool {
        self.splitter.server_functions
            .iter()
            .any(|f| f.name.value == name)
    }

    /// Returns statistics about the generated code
    pub fn stats(&self) -> EmitterStats {
        EmitterStats {
            server_functions: self.splitter.server_functions.len(),
            client_functions: self.splitter.client_functions.len(),
            shared_functions: self.splitter.shared_functions.len(),
            client_components: self.splitter.client_components.len(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct EmitterStats {
    pub server_functions: usize,
    pub client_functions: usize,
    pub shared_functions: usize,
    pub client_components: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::Lexer;
    use crate::parser::Parser;

    #[test]
    fn test_server_js_generation() {
        let source = r#"
            @server
            fn get_user(id: i32) -> String {
                return "John Doe";
            }

            fn format_name(first: String, last: String) -> String {
                return first + " " + last;
            }
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut tokens = Vec::new();
        loop {
            let token = lexer.next_token();
            let is_eof = token.kind == crate::token::TokenKind::Eof;
            tokens.push(token);
            if is_eof { break; }
        }

        let mut parser = Parser::new(tokens);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let server_js = emitter.generate_server_js();

        // Verify server.js contains expected code
        assert!(server_js.contains("HttpServer"));
        assert!(server_js.contains("function get_user"));
        assert!(server_js.contains("function format_name"));
        assert!(server_js.contains("WebAssembly"));
        assert!(server_js.contains("server.rpc('get_user'"));
    }

    #[test]
    fn test_client_js_generation() {
        let source = r#"
            @server
            fn get_user(id: i32) -> String {
                return "John Doe";
            }

            @client
            fn render_user(name: String) -> String {
                return "User: " + name;
            }

            fn format_name(first: String, last: String) -> String {
                return first + " " + last;
            }
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut tokens = Vec::new();
        loop {
            let token = lexer.next_token();
            let is_eof = token.kind == crate::token::TokenKind::Eof;
            tokens.push(token);
            if is_eof { break; }
        }

        let mut parser = Parser::new(tokens);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let client_js = emitter.generate_client_js();

        // Verify client.js contains expected code
        assert!(client_js.contains("RPCClient"));
        assert!(client_js.contains("async function get_user"));  // RPC stub
        assert!(client_js.contains("export function render_user"));  // Client function
        assert!(client_js.contains("export function format_name"));  // Shared function
        assert!(client_js.contains("DOMContentLoaded"));
    }

    #[test]
    fn test_stats() {
        let source = r#"
            @server fn s1() {}
            @server fn s2() {}
            @client fn c1() {}
            fn shared1() {}
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut tokens = Vec::new();
        loop {
            let token = lexer.next_token();
            let is_eof = token.kind == crate::token::TokenKind::Eof;
            tokens.push(token);
            if is_eof { break; }
        }

        let mut parser = Parser::new(tokens);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let stats = emitter.stats();

        assert_eq!(stats.server_functions, 2);
        assert_eq!(stats.client_functions, 1);
        assert_eq!(stats.shared_functions, 1);
        assert_eq!(stats.client_components, 0);
    }
}
